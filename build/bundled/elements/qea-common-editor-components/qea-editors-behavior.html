<html><head><script>
/* eslint-disable object-shorthand */

/**
This behavior will help you in the creation of a custom editor for an ASQ question type.

*/

window.qeaBehaviors = window.qeaBehaviors || {};
/**
 * `qeaBehaviors.appBehavior` implements general editing functionality.
 *
 * @polymerBehavior qeaBehaviors.generalEditorsBehavior
 */
qeaBehaviors.generalEditorsBehavior = {
  properties: {
    /**
    * The id of the question. DON'T MODIFY
    * It will be automatically set
    */
    id: String,
    /**
    * The id of the exercise that contains this question. DON'T MODIFY
    * It will be automatically set
    */
    exerciseId: String,
    /**
    * Object useful to store the result of a qea-property-editor-repeater.
    * if you add more qea-property-editor-repeater be sure to assign an id to them,
    * equal to the name of the property that you are using to store the value
    * @type {{<propName>: <propVAlue> ...}}
    */
    qeaRepeatValues: {
      type: Object,
      value: function value() {
        return {};
      }
    },
    /**
    * Toggle the view of advanced question.
    * Bind to is-Advanced-User inside a qea-property-editor-repeater or a qea-property-editor element
    */
    viewAdvanced: {
      type: String,
      value: 'false'
    },
    /**
    * Object containing the last state. DON'T MODIFY.
    * It will be automatically set only when you are editing an already existing question.
    * It useful to have an observer on this property, to call the _restoreQuestionState function
    */
    restoreState: {
      type: Object,
      observer: '_restoreQuestionState'
    },
    /**
    * Property containing the solution of the question
    */
    questionSolution: String
  },

  /**
  * Toggle the visibility of advanced questions
  */
  _showAdvanced: function _showAdvanced() {
    this.viewAdvanced = this.viewAdvanced === 'true' ? 'false' : 'true';
    if (this.$.advanced) {
      this.$.advanced.textContent = this.viewAdvanced === 'true' ? 'hide advanced' : 'show all';
    }
  },

  /**
  * Function responsible to restore all the values
  * @param {Object} state last state of the question editor.
  */
  _restoreQuestionState: function _restoreQuestionState() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var allRepeaters = Polymer.dom(this.root).querySelectorAll('qea-property-editor-repeater');
    var prop = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(state)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        prop = _step.value;

        this[prop] = state[prop];
      }
      // need to wait the rendering
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    Polymer.dom.flush();
    var repeater = void 0;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = allRepeaters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        repeater = _step2.value;

        if (state[repeater.id]) {
          var qProps = Polymer.dom(repeater.root).querySelectorAll('qea-property-editor');
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = qProps[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var spProp = _step3.value;

              spProp.value = state[repeater.id][spProp.name];
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  },

  /**
  * Function responsible to generate an object containing all the properties
  * needed to save the current state of the question editor
  * @param {Array<String>=} propertyToInclude array containing all the custom properties to be savd
  * @return {Object} An object who has as keys the properties you have passed and some default ones
  */
  _getQuestionState: function _getQuestionState(propertyToInclude) {
    var props = propertyToInclude || [];
    props.push('exerciseId');
    props.push('viewAdvanced');
    props.push('qeaRepeatValues');
    if (this.questionSolution) {
      props.push('questionSolution');
    }
    props = Array.from(new Set(props));
    var state = {};
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = props[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var prop = _step4.value;

        state[prop] = this[prop];
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    return state;
  },

  /**
  * Function responsible to communicate with the redux store and change the page.
  * @param {String} solution The soluton for the question Default value of questionSolution,
  * @param {Array<String>=} propertyToInclude array containing all the custom properties to be savd
  */
  _saveQuestion: function _saveQuestion(propertiesToSave) {
    var _this = this;

    var solution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.questionSolution;
    // eslint-disable-line consistent-return
    var toast = Polymer.dom(this.root).querySelector('qea-user-response');
    if (!solution && solution !== false || solution === '') {
      toast.notifyConfirm('Warning', '<p>you haven\'t provided a solution for this question.</p>\n        <p>Do you want to continue anyway?</p>').then(function (resp) {
        if (resp) {
          var code = _this._getFormattedCode();
          var state = _this._getQuestionState(propertiesToSave);
          if (_this.id) {
            _this.dispatch('editElement', _this.id, code, state);
          } else {
            _this.dispatch('addElement', _this.tagName.toLowerCase(), code, state);
          }
          _this._previousPage();
          return true;
        }
        return false;
      });
    } else {
      var code = this._getFormattedCode();
      var state = this._getQuestionState(propertiesToSave);
      if (this.id) {
        this.dispatch('editElement', this.id, code, state);
      } else {
        this.dispatch('addElement', this.tagName.toLowerCase().substring(0, this.tagName.length - 7), code, state);
      }
      this._previousPage();
      return true;
    }
  },

  /**
  * function responsible to return a string representing the HTML code of the question generated;
  * since each editor is specific for a question, you'll need to override this function in every editor
  * @return {Strng}
  */
  _getFormattedCode: function _getFormattedCode() {
    return '';
  },

  /**
  * function responsible to help the user in the insertion of a solution for the question.
  * This function needs to be called before _saveQuestion.
  * @param {String} slValue solution value.
  * @return {Boolean} true if solution set without problem false otherwise
  */
  _setSolution: function _setSolution(slValue) {
    var _this2 = this;

    var toast = Polymer.dom(this.root).querySelector('qea-user-response');
    if (!slValue && slValue !== false || slValue === '') {
      toast.notifyError('Error', "you haven't provided a solution for this question");
      return;
    }
    this.questionSolution = '';
    toast.notifyConfirm('Is the solution correct?', 'Solution:  ' + slValue).then(function (resp) {
      if (resp) {
        _this2.questionSolution = slValue;
      }
    });
  },

  /**
  * function use to abort the editing of a question and move back to the canvas page
  */
  _cancel: function _cancel() {
    var _this3 = this;

    var toast = Polymer.dom(this.root).querySelector('qea-user-response');
    toast.notifyConfirm('Do you really want to exit?', 'all the chenges will be lost').then(function (resp) {
      if (resp) {
        _this3._previousPage();
      }
    });
  },

  _previousPage: function _previousPage() {
    if (this.exerciseId) {
      this.fire('changePage', { pageURL: '/exercise/' + this.exerciseId });
    } else {
      this.fire('changePage', { pageURL: '/home' });
    }
  }
};</script></head><body></body></html>