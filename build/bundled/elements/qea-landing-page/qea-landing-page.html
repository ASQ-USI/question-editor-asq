<html><head></head><body><div hidden="" by-polymer-bundler=""><dom-module id="iron-image" assetpath="../../bower_components/iron-image/"><template><style>:host{display:inline-block;overflow:hidden;position:relative;}#sizedImgDiv{@apply (--layout-fit);display:none;}#img{display:block;width:var(--iron-image-width, auto);height:var(--iron-image-height, auto);}:host([sizing]) #sizedImgDiv{display:block;}:host([sizing]) #img{display:none;}#placeholder{@apply (--layout-fit);background-color:inherit;opacity:1;@apply (--iron-image-placeholder);}#placeholder.faded-out{transition:opacity 0.5s linear;opacity:0;}</style><div id="sizedImgDiv" role="img" hidden$="[[_computeImgDivHidden(sizing)]]" aria-hidden$="[[_computeImgDivARIAHidden(alt)]]" aria-label$="[[_computeImgDivARIALabel(alt, src)]]"></div><img id="img" alt$="[[alt]]" hidden$="[[_computeImgHidden(sizing)]]"><div id="placeholder" hidden$="[[_computePlaceholderHidden(preload, fade, loading, loaded)]]" class$="[[_computePlaceholderClassName(preload, fade, loading, loaded)]]"></div></template><script>
Polymer({
  is: 'iron-image',

  properties: {
    /**
     * The URL of an image.
     */
    src: {
      observer: '_srcChanged',
      type: String,
      value: ''
    },

    /**
     * A short text alternative for the image.
     */
    alt: {
      type: String,
      value: null
    },

    /**
     * When true, the image is prevented from loading and any placeholder is
     * shown.  This may be useful when a binding to the src property is known to
     * be invalid, to prevent 404 requests.
     */
    preventLoad: {
      type: Boolean,
      value: false,
      observer: '_preventLoadChanged'
    },

    /**
     * Sets a sizing option for the image.  Valid values are `contain` (full
     * aspect ratio of the image is contained within the element and
     * letterboxed) or `cover` (image is cropped in order to fully cover the
     * bounds of the element), or `null` (default: image takes natural size).
     */
    sizing: {
      type: String,
      value: null,
      reflectToAttribute: true
    },

    /**
     * When a sizing option is used (`cover` or `contain`), this determines
     * how the image is aligned within the element bounds.
     */
    position: {
      type: String,
      value: 'center'
    },

    /**
     * When `true`, any change to the `src` property will cause the `placeholder`
     * image to be shown until the new image has loaded.
     */
    preload: {
      type: Boolean,
      value: false
    },

    /**
     * This image will be used as a background/placeholder until the src image has
     * loaded.  Use of a data-URI for placeholder is encouraged for instant rendering.
     */
    placeholder: {
      type: String,
      value: null,
      observer: '_placeholderChanged'
    },

    /**
     * When `preload` is true, setting `fade` to true will cause the image to
     * fade into place.
     */
    fade: {
      type: Boolean,
      value: false
    },

    /**
     * Read-only value that is true when the image is loaded.
     */
    loaded: {
      notify: true,
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Read-only value that tracks the loading state of the image when the `preload`
     * option is used.
     */
    loading: {
      notify: true,
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Read-only value that indicates that the last set `src` failed to load.
     */
    error: {
      notify: true,
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Can be used to set the width of image (e.g. via binding); size may also be
     * set via CSS.
     */
    width: {
      observer: '_widthChanged',
      type: Number,
      value: null
    },

    /**
     * Can be used to set the height of image (e.g. via binding); size may also be
     * set via CSS.
     *
     * @attribute height
     * @type number
     * @default null
     */
    height: {
      observer: '_heightChanged',
      type: Number,
      value: null
    }
  },

  observers: ['_transformChanged(sizing, position)'],

  ready: function ready() {
    var img = this.$.img;

    img.onload = function () {
      if (this.$.img.src !== this._resolveSrc(this.src)) return;

      this._setLoading(false);
      this._setLoaded(true);
      this._setError(false);
    }.bind(this);

    img.onerror = function () {
      if (this.$.img.src !== this._resolveSrc(this.src)) return;

      this._reset();

      this._setLoading(false);
      this._setLoaded(false);
      this._setError(true);
    }.bind(this);

    this._resolvedSrc = '';
  },

  _load: function _load(src) {
    if (src) {
      this.$.img.src = src;
    } else {
      this.$.img.removeAttribute('src');
    }
    this.$.sizedImgDiv.style.backgroundImage = src ? 'url("' + src + '")' : '';

    this._setLoading(!!src);
    this._setLoaded(false);
    this._setError(false);
  },

  _reset: function _reset() {
    this.$.img.removeAttribute('src');
    this.$.sizedImgDiv.style.backgroundImage = '';

    this._setLoading(false);
    this._setLoaded(false);
    this._setError(false);
  },

  _computePlaceholderHidden: function _computePlaceholderHidden() {
    return !this.preload || !this.fade && !this.loading && this.loaded;
  },

  _computePlaceholderClassName: function _computePlaceholderClassName() {
    return this.preload && this.fade && !this.loading && this.loaded ? 'faded-out' : '';
  },

  _computeImgDivHidden: function _computeImgDivHidden() {
    return !this.sizing;
  },

  _computeImgDivARIAHidden: function _computeImgDivARIAHidden() {
    return this.alt === '' ? 'true' : undefined;
  },

  _computeImgDivARIALabel: function _computeImgDivARIALabel() {
    if (this.alt !== null) {
      return this.alt;
    }

    // Polymer.ResolveUrl.resolveUrl will resolve '' relative to a URL x to
    // that URL x, but '' is the default for src.
    if (this.src === '') {
      return '';
    }

    var pathComponents = new URL(this._resolveSrc(this.src)).pathname.split("/");
    return pathComponents[pathComponents.length - 1];
  },

  _computeImgHidden: function _computeImgHidden() {
    return !!this.sizing;
  },

  _widthChanged: function _widthChanged() {
    this.style.width = isNaN(this.width) ? this.width : this.width + 'px';
  },

  _heightChanged: function _heightChanged() {
    this.style.height = isNaN(this.height) ? this.height : this.height + 'px';
  },

  _preventLoadChanged: function _preventLoadChanged() {
    if (this.preventLoad || this.loaded) return;

    this._reset();
    this._load(this.src);
  },

  _srcChanged: function _srcChanged(newSrc, oldSrc) {
    var newResolvedSrc = this._resolveSrc(newSrc);
    if (newResolvedSrc === this._resolvedSrc) return;
    this._resolvedSrc = newResolvedSrc;

    this._reset();
    if (!this.preventLoad) {
      this._load(newSrc);
    }
  },

  _placeholderChanged: function _placeholderChanged() {
    this.$.placeholder.style.backgroundImage = this.placeholder ? 'url("' + this.placeholder + '")' : '';
  },

  _transformChanged: function _transformChanged() {
    var sizedImgDivStyle = this.$.sizedImgDiv.style;
    var placeholderStyle = this.$.placeholder.style;

    sizedImgDivStyle.backgroundSize = placeholderStyle.backgroundSize = this.sizing;

    sizedImgDivStyle.backgroundPosition = placeholderStyle.backgroundPosition = this.sizing ? this.position : '';

    sizedImgDivStyle.backgroundRepeat = placeholderStyle.backgroundRepeat = this.sizing ? 'no-repeat' : '';
  },

  _resolveSrc: function _resolveSrc(testSrc) {
    var baseURI = /** @type {string} */this.ownerDocument.baseURI;
    return new URL(Polymer.ResolveUrl.resolveUrl(testSrc, baseURI), baseURI).href;
  }
});</script></dom-module><dom-module id="paper-card" assetpath="../../bower_components/paper-card/"><template><style include="paper-material">:host{display:inline-block;position:relative;box-sizing:border-box;background-color:var(--paper-card-background-color, --primary-background-color);border-radius:2px;@apply (--paper-font-common-base);@apply (--paper-card);}[hidden]{display:none !important;}.header{position:relative;border-top-left-radius:inherit;border-top-right-radius:inherit;overflow:hidden;@apply (--paper-card-header);}.header iron-image{display:block;width:100%;--iron-image-width:100%;pointer-events:none;@apply (--paper-card-header-image);}.header .title-text{padding:16px;font-size:24px;font-weight:400;color:var(--paper-card-header-color, #000);@apply (--paper-card-header-text);}.header .title-text.over-image{position:absolute;bottom:0px;@apply (--paper-card-header-image-text);}:host ::content .card-content{padding:16px;position:relative;@apply (--paper-card-content);}:host ::content .card-actions{border-top:1px solid #e8e8e8;padding:5px 16px;position:relative;@apply (--paper-card-actions);}</style><div class="header"><iron-image hidden$="[[!image]]" aria-hidden$="[[_isHidden(image)]]" src="[[image]]" alt="[[alt]]" placeholder="[[placeholderImage]]" preload="[[preloadImage]]" fade="[[fadeImage]]"></iron-image><div hidden$="[[!heading]]" class$="title-text [[_computeHeadingClass(image)]]">[[heading]]</div></div><content></content></template><script>
Polymer({
  is: 'paper-card',

  properties: {
    /**
     * The title of the card.
     */
    heading: {
      type: String,
      value: '',
      observer: '_headingChanged'
    },

    /**
     * The url of the title image of the card.
     */
    image: {
      type: String,
      value: ''
    },

    /**
     * The text alternative of the card's title image.
     */
    alt: {
      type: String
    },

    /**
     * When `true`, any change to the image url property will cause the
     * `placeholder` image to be shown until the image is fully rendered.
     */
    preloadImage: {
      type: Boolean,
      value: false
    },

    /**
     * When `preloadImage` is true, setting `fadeImage` to true will cause the
     * image to fade into place.
     */
    fadeImage: {
      type: Boolean,
      value: false
    },

    /**
     * This image will be used as a background/placeholder until the src image has
     * loaded. Use of a data-URI for placeholder is encouraged for instant rendering.
     */
    placeholderImage: {
      type: String,
      value: null
    },

    /**
     * The z-depth of the card, from 0-5.
     */
    elevation: {
      type: Number,
      value: 1,
      reflectToAttribute: true
    },

    /**
     * Set this to true to animate the card shadow when setting a new
     * `z` value.
     */
    animatedShadow: {
      type: Boolean,
      value: false
    },

    /**
     * Read-only property used to pass down the `animatedShadow` value to
     * the underlying paper-material style (since they have different names).
     */
    animated: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      computed: '_computeAnimated(animatedShadow)'
    }
  },

  /**
   * Format function for aria-hidden. Use the ! operator results in the
   * empty string when given a falsy value.
   */
  _isHidden: function _isHidden(image) {
    return image ? 'false' : 'true';
  },

  _headingChanged: function _headingChanged(heading) {
    var currentHeading = this.getAttribute('heading'),
        currentLabel = this.getAttribute('aria-label');

    if (typeof currentLabel !== 'string' || currentLabel === currentHeading) {
      this.setAttribute('aria-label', heading);
    }
  },

  _computeHeadingClass: function _computeHeadingClass(image) {
    return image ? ' over-image' : '';
  },

  _computeAnimated: function _computeAnimated(animatedShadow) {
    return animatedShadow;
  }
});</script></dom-module><link rel="import" href="../qea-common-editor-components/qea-user-response.html"></div><dom-module id="qea-landing-page"><template><style>:host{display:block;@apply (--layout-horizontal);}.container{position:relative;@apply (--layout-flex);}.container paper-fab{position:absolute;color:black;--paper-fab-background:white;right:40px;bottom:40px;}#fabButton{--paper-fab-background:#7CB342;color:white;}.card{margin:20px;}#remove{color:#f44336;}</style><app-location route="{{route}}"></app-location><qea-user-response id="notify"></qea-user-response><iron-localstorage name="my-app-storage" value="{{exerciseStore}}"></iron-localstorage><div class="container"><template is="dom-if" if="[[_checkStore(exerciseStore)]]"><paper-card class="card"><div class="card-content"><p>we have foud a presentation<br>do you whant to restore it?</p></div><div class="card-actions"><paper-button id="remove" on-tap="_remove">remove</paper-button><paper-button id="restore" on-tap="_restore">restore</paper-button></div></paper-card></template><paper-fab id="fabButton" icon="add" on-tap="_newExercise"></paper-fab></div></template><script>
(function () {
  'use strict';

  Polymer({

    is: 'qea-landing-page',
    properties: {
      exerciseStore: {
        type: Object,
        value: function value() {
          return {};
        }
      },
      /**
      * Route
      */
      route: {
        type: Object,
        notify: true
      }
    },

    // go to new page
    _newExercise: function _newExercise() {
      var _this = this;

      if (this._checkStore(this.exerciseStore)) {
        this.$.notify.notifyConfirm('Warning', 'if you continue presentation will be overridden').then(function (responce) {
          if (responce) {
            _this.fire('changePage', { pageURL: '/exercise/new' });
          }
        });
      } else {
        this.fire('changePage', { pageURL: '/exercise/new' });
      }
    },

    _checkStore: function _checkStore() {
      var store = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (store && store.elements) {
        return store.elements.length > 0;
      }
      return false;
    },

    _restore: function _restore() {
      this.fire('changePage', { pageURL: '/exercise/' + this.exerciseStore.eid });
    },

    _remove: function _remove() {
      this.exerciseStore = null;
    }
  });
})();</script></dom-module></body></html>